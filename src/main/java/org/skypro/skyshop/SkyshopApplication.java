package org.skypro.skyshop;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SkyshopApplication {

    public static void main(String[] args) {

        SpringApplication.run(SkyshopApplication.class, args);
    }
}
/*
ВВЕДЕНИЕ В ВЕБ-ПРОГРАММИРОВАНИЕ С ИСПОЛЬЗОВАНИЕМ SPRING BOOT

    Шаг 1. Перенос модели
    	Для начала перенесем модель интернет-магазина в Spring. Как вы помните, у нас было две сущности — абстрактный Товар (Product) и
    Статья (Article). У товара было три класса-потомка. Также мы создавали интерфейс Searchable, чтобы пользоваться поиском с помощью
    поискового движка.
    	Начните с создания пакета model, в который мы будем переносить эти классы. Этот пакет нужно создать в корневом пакете приложения.
    	Далее перенесите по очереди следующие классы:
    		1.	Интерфейс Searchable — для него нужно будет создать пакет model.search.
    		2.	Классы товаров Product — в пакет model.product.
    		3.	Класс статьи Article — в пакет model.article.
    	После этого проверьте, что проект компилируется.

    	Пока никакой функциональности мы не перенесли, поэтому запросы через браузер ничего не дадут.

    Шаг 2. Добавления идентификаторов
    	В веб-приложениях принято, что каждая сущность имеет идентификатор — для быстрого доступа к себе. Обычно эти идентификаторы
    представляют некоторые числовые значения или UUID — специальный вид уникального идентификатора.

    В проекте используйте UUID в качестве идентификаторов.

    	Для начала добавим к нашим сущностям идентификаторы:
    		•	В интерфейс Searchable добавьте метод getId(), который возвращает UUID(java.util.UUID).
    		•	Реализуйте этот метод в классах Article и Product. Для этого в них нужно:
    			o	Завести private final-поле с типом UUID, которое называется id.
    			o	Добавить геттер для этого поля. После добавления геттера эти классы начнут реализовывать интерфейс Searchable.

    				Сами поля id нужно принимать в конструкторе, модифицируя его и добавив поле id в список параметров конструктора.

    			o	В случае с Product добавьте поле id в конструкторы всех классов-потомков, так как конструкторы не наследуются.

    Шаг 3. Добавления сервиса хранения
    	До этого этапа  у нас не было отдельного сервиса хранения продуктов и статей, так как мы создавали их в методе main —
    только для демонстрации.
    	Но в веб-приложения, чтобы обращаться к нашим сущностям, нам нужно хранить их где-то в памяти. Для этого нужно
    написать сервис для хранения.
    	1.	Создайте класс StorageService в пакете service. Этот класс должен содержать в себе две private final:
    		o	Map<UUID, Product> — хранилище продуктов,
	    	o	Map<UUID,Article> — хранилище статей.
    	Данный Map нужно создавать в конструкторе класса StorageService.
    	2.	Напишите два метода:
    		o	возвращающий коллекцию всех статей,
    		o	возвращающий коллекцию всех продуктов.
    	3.	В конструкторе сервиса заполните эти мапы тестовыми данными из метода main нашего предыдущего проекта.
    		Для этого лучше всего сделать отдельный приватный метод и вызывать его в конструкторе.
    		Помните: теперь нужно добавлять всем объектам идентификаторы. Это можно сделать с помощью метода UUID.randomUUID().
    	4.	Добавьте над классом StorageService аннотацию @Service, чтобы Spring мог зарегистрировать его как управляемый объект
    		и предоставлять этот класс другим классам.

    Шаг 4. Добавление контроллера
    	Теперь выведем содержимое StorageService в браузер.
    	Для этого создайте класс контроллера ShopController в пакете controller. Этот класс должен обращаться к сервису StorageService
    и получать продукты и статьи.
    	Чтобы контроллер корректно работал и возвращал JSON-ответы, обязательно пометьте его аннотацией @RestController.
    Без неё ваш контроллер не будет обрабатываться как REST, и браузер не получит нужные данные.

    		@RestController
    		public class ShopController {
        		// ...
    		}

    	Создадим два метода, которые должны возвращать соответственно все продукты или все статьи, доступные в StorageService.

    		@GetMapping("/products")
    		public Collection<Product> getAllProducts()

    		@GetMapping("/articles")
    		public Collection<Article> getAllArticles()

    	Spring умный. Когда он увидит в возвращаемых аргументах класс, который не является строкой, то переведет его в специальный формат JSON
    (подробнее о нем мы поговорим в следующих уроках курса).
    	После добавления контроллера проверьте, что в браузере:
    		•	при открытии localhost:8080/products доступен список тестовых продуктов,
    		•	при открытии  localhost:8080/articles — список статей.
    	Возможно вы заметили, что в возвращаемых данных присутствуют строки searchTerm и contentType. Давайте сделаем так,
    чтобы они не выводились. Для этого добавьте аннотацию @JsonIgnore над методами геттерами getSearchTerm и getContentType в классах
    Product и Article соответственно.

    Шаг 5. Восстановление функциональности поиска
    	Чтобы восстановить поиск выполните следующие действия:
    	1.	Создайте новый класс SearchResult,  который будет моделью результата поиска.
    		Добавьте в него строковые поля id, name и contentType. Класс должен быть неизменяемым (immutalbe). Это значит,
    		что все поля должны иметь модификатор final и задаваться в конструкторе. Не забудьте поместить класс в нужный пакет.
    	2.	Для простоты создания SearchResult из интерфейса Searchable напишите публичный статический метод fromSearchable
    		внутри класса SearchResult. Метод должен принимать Searchable и возвращать SearchResult с заполненными полями.

    	Такой способ создания объектов называется статический фабричный метод. Он часто используется, чтобы инкапсулировать
    	логику создания объекта в классе самого объекта.

    	3.	Добавьте сервис поиска SearchService в пакет service. В этом сервисе будет много изменений,
    		поэтому проще не переносить старый класс, а написать новый. В сервисе поиска нам нужно добавить сервис хранения
    		(StorageService) как зависимость нашего SearchService и заставить спринг принести нам этот класс через конструктор. Для этого:
    			o	добавьте его как private final поле
    			o	и инициализируйте в конструкторе.
    		Не забудьте пометить SearchService как @Service с помощью аннотации.
    	4.	Теперь сделайте так, чтобы сервис хранения (StorageService) умел возвращать нам коллекцию объектов типа Searchable,
    		по которой мы сможем искать в SearchService. Для этого напишите в StorageService метод, который возвращает коллекцию
    		Searchable путем объединения всех статей и всех продуктов в одну коллекцию внутри метода.
    	5.	Напишем новый метод search в классе SearchService. Он должен принимать строку для поиска и возвращать коллекцию
    		объектов SearchResult. Для написания метода воспользуйтесь Stream API. Сортировать результаты и дополнительно
    		обрабатывать пока не надо.
    	6.	Добавьте новый метод в контроллер. Это должен быть @GET-метод с путем /search. Он должен принимать аргумент pattern,
    		который будет той самой строкой поиска. Метод должен возвращать коллекцию объектов SearchResult.

    	Если все выполнено правильно и по шагам, при запросе localhost:8080/search?pattern=<какая-то строка> вы получите
    	результаты поиска или пустой список.

    Критерии оценки
    Работа будет оценена по следующим критериям
    	1. Пакеты model, model.search, model.product, model.article созданы, классы размещены согласно условиям.
    	2. Поле id есть во всех классах, объявлено как private final, инициализировано в конструкторе
    	3. Метод getId() корректно реализован в Product, Article и интерфейсе Searchable
    	4. Классы помечены @Service
    	5. Обе мапы объявлены как private final, инициализированы в конструкторе
    	6. Тестовые объекты созданы с уникальными UUID, добавлены в мапы через отдельный приватный метод
    	7. Класс помечен @RestController, методы search(), getAllProducts() и getAllArticles() — @GetMapping
    	8. Поля searchTerm и contentType отсутствуют в JSON-ответе
    	9. Поля id, name, contentType — final, сеттеры отсутствуют
    	10. Метод fromSearchable() есть, корректно преобразует Searchable в SearchResult (соответствующие поля в соответствующие поля, то есть name в name)
    	11. Поле StorageService помечено как private final, инициализировано через конструктор
    	12. Поля SearchService и StorageService помечены как private final, инициализировано через конструктор
    	13. Поиск реализован через цепочку stream().filter(...).map(...).collect(...)
    	14. Эндпоинт возвращает отфильтрованные результаты в виде коллекции SearchResult

ЖИЗНЕННЫЙ ЦИКЛ КОМПОНЕНТОВ SPRING BOOT ПРИЛОЖЕНИЯ

    Шаг 1. Добавление компонента корзины
            Корзина будет представлять из себя @SessionScope. Компонент внутри будет содержать только Map с id товара в качестве ключа и
        Integer в качестве значения. Integer нам нужен, так как один товар можно добавлять в корзину несколько раз.
            Создайте класс ProductBasket в подпакете model.basket с private final полем с мапой товаров и их количеством и двумя методами:
 *           1.	Метод добавления продукта в корзину. Он будет принимать UUID id и не будет ничего возвращать.
            2.	Метод получения всех продуктов, которые сейчас есть в корзине. Он должен возвращать ту же мапу Map<UUID, Integer>, которая хранится в поле.
                Чтобы защитить нас от возможных изменений этой мапы, нужно обернуть ее в Collections.unmodifiableMap.

    Шаг 2. Сервис работы с корзиной
            Этот сервис будет объединять наш новый компонент с контроллером и позволит нам добавлять в корзину
        товары и показывать текущее состояние корзины пользователю.
            Создайте класс BasketService в пакете service. В этом классе нам нужны два private final поля. Одно поле будет
        содержать наш компонент корзины, а второе — StorageService. Эти поля нужно инициализировать через конструктор, как обычно, используя constructor injection.
        Класс сервиса должен содержать два метода:
        1.	Метод добавления товара в корзину по id.
            Этот метод должен принимать UUID id и ничего не возвращать. Внутри метода вам нужно обратиться к StorageService и
        проверить, есть ли переданный в аргументах id в списке продуктов.
            Для этого допишите метод в StorageService, который получает продукт по id и возвращает Optional<Product>.

            public Optional<Product> getProductById(UUID id) {
                return Optional.ofNullable(availableProducts.get(id));
            }

            После этого в теле метода вы обращаетесь к storage service, получаете Optional и, если он пустой (isPresent == false),
        то вам нужно выбросить IllegalArgumentException().
            Если же такой товар есть в StorageService, то достаточно добавить его в корзину, обратившись к ее компоненту.
        2.	Метод отображения корзины пользователю.
            Чтобы написать этот метод, вам нужно сделать подготовительную работу. Вам потребуется объект, представляющий корзину
        в виде JSON-объекта, чтобы показать его пользователю. Если мы будем просто отправлять Map<UUID, Integer> пользователю,
        то будет непонятно, какая стоимость корзины и какие продукты были добавлены.

        Для этого создадим несколько классов:
        1.	BasketItem — немодифицируемый класс с двумя полями — Product и его количество(int).
        2.	UserBasket — класс, представляющий корзину для пользователя. Этот класс должен содержать список из BasketItem,
        а также дополнительное поле total — общую стоимость корзины. Класс также должен быть немодифицируемым, а его конструктор
        должен принимать в себя только список BasketItem.

            Для подсчета общей стоимости используйте формулу: стоимость продукта × количество + стоимость продукта × количество и так далее.
        Попробуйте посчитать поле total с помощью StreamAPI.

            После подготовки этих классов, вернитесь в BasketService и НАПИШИТЕ МЕТОД getUserBasket, который возвращает корзину пользователя.
        Этот метод не должен ничего принимать и должен возвращать UserBasket.
            Внутри метода getUserBasket вам нужно:
            •	обратиться к компоненту корзины ProductBasket,
            •	получить мапу товаров из корзины
            •	и преобразовать ее в UserBasket.
            В этом вам снова поможет StreamAPI и StorageSerivce.

    Шаг 3. Методы контроллера
        В контроллер вам нужно добавить два метода.
        1.	Метод добавления продукта в корзину — @GetMapping(”/basket/{id}”). Этот метод должен возвращать строку вида “*Продукт успешно добавлен*”.

            @GetMapping("/basket/{id}")
            public String addProduct(@PathVariable("id") UUID id)

        PathVariable — специальный аргумент, похожий на параметр запроса. Но в этом случае в качестве аргумента мы выделяем часть URL.
        То есть при запросе http://localhost:8080/basket/d648c957-cad1-4b84-b953-62849f7a3806 в параметре id у нас окажется
        UUID вида d648c957-cad1-4b84-b953-62849f7a3806.

        2.	Метод отображения корзины.

            @GetMapping("/basket")
            public UserBasket getUserBasket()

    Шаг 4. Проверка работоспособности
        После того, как вы добавили методы и их реализации, проверьте все добавленные методы. Для этого:
            •	Откройте страницу со всеми продуктами и создайте рядом новую вкладку в браузере.
            •	В новой вкладке впишите адрес
                http://localhost:8080/basket/<ID из вкладки со всеми продуктами>. Так вы добавите продукт в корзину.
            •	После этого проверьте добавление с помощью запроса
                http://localhost:8080/basket.
            •	Добавьте несколько продуктов и убедитесь: если открывать новую вкладку в режиме инкогнито, то корзина в ней должна быть пустой.

    Работа будет оценена по следующим критериям
        1. Класс объявлен в пакете model.basket, имеет аннотации @Component и @SessionScope
        2. Поле объявлено как private final, инициализировано HashMap
        3. Метод добавления продукта реализован корректно, с увеличением количества или добавлением с 1, использован метод computeIfAbsent
        4. Метод получения корзины возвращает Collections.unmodifiableMap()
        5. Поля private final, внедрение через конструктор с @Autowired. Класс помечен аннотацией @Service
        6. Использован Optional с orElseThrow для проверки и выброса исключения
        7. Поля private final, есть конструктор и геттеры, отсутствуют сеттеры; total вычисляется в конструкторе
        8. Конструктор принимает List<BasketItem>, total вычисляется через items.stream().mapToInt(...).sum()
        9. Использован Stream API
        10. Методы addProduct и getUserBasket реализованы с указанными путями и параметрами
        11. Корзина в новой сессии пуста, изменения в одной сессии не влияют на другую

ЗАВИСИМОСТИ И ИСКЛЮЧЕНИЯ В SPRING BOOT

    Шаг 1. Скачайте архив
        Скачайте архив с кодом приложения, рассматриваемого в уроке, и дополнительными примерами.

        Ссылка: https://drive.google.com/file/d/1AYLnTBR8NcHsJZnK1EciBchF8Z4qgcSO/view?usp=sharing.

        Обратите внимание на комментарии в классе org.skypro.counter.controller.MathController — они покажут, как воспроизвести ожидаемое поведение.

    Шаг 2. Свое исключение и модификация сервиса
            Добавьте свое исключение NoSuchProductException унаследованное от RuntimeException.
            Во всех местах где используется метод getProductById класса StorageService, вместо IllegalArgumentException
        нужно выкидывать новое исключение — NoSuchProductException.

    Шаг 3. Модель ошибки
            Ошибку, которая говорит о том что товар не найден, мы будем возвращать пользователю в виде JSON. Для этого нам понадобится отдельный класс,
        который можно назвать ShopError. Он будет немодифицируемым и иметь два строковых поля:
        •	code: код ошибки в виде строки.
        •	message: сообщение об ошибке.
            Код ошибки часто используют, чтобы получить машиночитаемое значение для ошибки, локализовать ее на нужный язык или выполнить другое действие при получении этой ошибки.
            Эти коды обычно отличаются от HTTP-кодов и являются более конкретными. Например: на HTTP-код четыреста могут приходиться несколько разных ошибок с разным смыслом.

    Шаг 4. Controller Advice
            Вам нужно будет создать класс который называется ShopControllerAdvice и написать внутри него обработчик нашего
        исключения NoSuchProductException. Обработчик должен возвращать ResponseEntity<ShopError> с HTTP кодом 404.
            Выберите код ошибки и сообщение самостоятельно.

    Критерии оценки
        1. Исключение NoSuchProductException унаследовано от RuntimeException, содержит конструктор — либо с параметром,
            либо без, при этом super вызывается со значимым текстом (например, «Товар не найден»).
        2. В методе добавления продукта в корзину выбрасывается NoSuchProductException в случае отсутствия товара
        3. Класс ShopError имеет два поля: code и message, оба объявлены как final
        4. Обработчик корректно возвращает ResponseEntity<ShopError> с установленным HTTP-кодом 404 и сообщением из исключения;
            присутствуют аннотации @ControllerAdvice и @ExceptionHandler

 */