package org.skypro.skyshop;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SkyshopApplication {

    public static void main(String[] args) {

        SpringApplication.run(SkyshopApplication.class, args);
    }
}
/*
Шаг 1. Перенос модели
	Для начала перенесем модель интернет-магазина в Spring. Как вы помните, у нас было две сущности — абстрактный Товар (Product) и
Статья (Article). У товара было три класса-потомка. Также мы создавали интерфейс Searchable, чтобы пользоваться поиском с помощью
поискового движка.
	Начните с создания пакета model, в который мы будем переносить эти классы. Этот пакет нужно создать в корневом пакете приложения.
	Далее перенесите по очереди следующие классы:
		1.	Интерфейс Searchable — для него нужно будет создать пакет model.search.
		2.	Классы товаров Product — в пакет model.product.
		3.	Класс статьи Article — в пакет model.article.
	После этого проверьте, что проект компилируется.

	Пока никакой функциональности мы не перенесли, поэтому запросы через браузер ничего не дадут.

Шаг 2. Добавления идентификаторов
	В веб-приложениях принято, что каждая сущность имеет идентификатор — для быстрого доступа к себе. Обычно эти идентификаторы
представляют некоторые числовые значения или UUID — специальный вид уникального идентификатора.

В проекте используйте UUID в качестве идентификаторов.

	Для начала добавим к нашим сущностям идентификаторы:
		•	В интерфейс Searchable добавьте метод getId(), который возвращает UUID(java.util.UUID).
		•	Реализуйте этот метод в классах Article и Product. Для этого в них нужно:
			o	Завести private final-поле с типом UUID, которое называется id.
			o	Добавить геттер для этого поля. После добавления геттера эти классы начнут реализовывать интерфейс Searchable.

				Сами поля id нужно принимать в конструкторе, модифицируя его и добавив поле id в список параметров конструктора.

			o	В случае с Product добавьте поле id в конструкторы всех классов-потомков, так как конструкторы не наследуются.

Шаг 3. Добавления сервиса хранения
	До этого этапа  у нас не было отдельного сервиса хранения продуктов и статей, так как мы создавали их в методе main —
только для демонстрации.
	Но в веб-приложения, чтобы обращаться к нашим сущностям, нам нужно хранить их где-то в памяти. Для этого нужно
написать сервис для хранения.
	1.	Создайте класс StorageService в пакете service. Этот класс должен содержать в себе две private final:
		o	Map<UUID, Product> — хранилище продуктов,
		o	Map<UUID,Article> — хранилище статей.
	Данный Map нужно создавать в конструкторе класса StorageService.
	2.	Напишите два метода:
		o	возвращающий коллекцию всех статей,
		o	возвращающий коллекцию всех продуктов.
	3.	В конструкторе сервиса заполните эти мапы тестовыми данными из метода main нашего предыдущего проекта.
		Для этого лучше всего сделать отдельный приватный метод и вызывать его в конструкторе.
		Помните: теперь нужно добавлять всем объектам идентификаторы. Это можно сделать с помощью метода UUID.randomUUID().
	4.	Добавьте над классом StorageService аннотацию @Service, чтобы Spring мог зарегистрировать его как управляемый объект
		и предоставлять этот класс другим классам.

Шаг 4. Добавление контроллера
	Теперь выведем содержимое StorageService в браузер.
	Для этого создайте класс контроллера ShopController в пакете controller. Этот класс должен обращаться к сервису StorageService
и получать продукты и статьи.
	Чтобы контроллер корректно работал и возвращал JSON-ответы, обязательно пометьте его аннотацией @RestController.
Без неё ваш контроллер не будет обрабатываться как REST, и браузер не получит нужные данные.

		@RestController
		public class ShopController {
    		// ...
		}

	Создадим два метода, которые должны возвращать соответственно все продукты или все статьи, доступные в StorageService.

		@GetMapping("/products")
		public Collection<Product> getAllProducts()

		@GetMapping("/articles")
		public Collection<Article> getAllArticles()

	Spring умный. Когда он увидит в возвращаемых аргументах класс, который не является строкой, то переведет его в специальный формат JSON
(подробнее о нем мы поговорим в следующих уроках курса).
	После добавления контроллера проверьте, что в браузере:
		•	при открытии localhost:8080/products доступен список тестовых продуктов,
		•	при открытии  localhost:8080/articles — список статей.
	Возможно вы заметили, что в возвращаемых данных присутствуют строки searchTerm и contentType. Давайте сделаем так,
чтобы они не выводились. Для этого добавьте аннотацию @JsonIgnore над методами геттерами getSearchTerm и getContentType в классах
Product и Article соответственно.

Шаг 5. Восстановление функциональности поиска
	Чтобы восстановить поиск выполните следующие действия:
	1.	Создайте новый класс SearchResult,  который будет моделью результата поиска.
		Добавьте в него строковые поля id, name и contentType. Класс должен быть неизменяемым (immutalbe). Это значит,
		что все поля должны иметь модификатор final и задаваться в конструкторе. Не забудьте поместить класс в нужный пакет.
	2.	Для простоты создания SearchResult из интерфейса Searchable напишите публичный статический метод fromSearchable
		внутри класса SearchResult. Метод должен принимать Searchable и возвращать SearchResult с заполненными полями.

	Такой способ создания объектов называется статический фабричный метод. Он часто используется, чтобы инкапсулировать
	логику создания объекта в классе самого объекта.

	3.	Добавьте сервис поиска SearchService в пакет service. В этом сервисе будет много изменений,
		поэтому проще не переносить старый класс, а написать новый. В сервисе поиска нам нужно добавить сервис хранения
		(StorageService) как зависимость нашего SearchService и заставить спринг принести нам этот класс через конструктор. Для этого:
			o	добавьте его как private final поле
			o	и инициализируйте в конструкторе.
		Не забудьте пометить SearchService как @Service с помощью аннотации.
	4.	Теперь сделайте так, чтобы сервис хранения (StorageService) умел возвращать нам коллекцию объектов типа Searchable,
		по которой мы сможем искать в SearchService. Для этого напишите в StorageService метод, который возвращает коллекцию
		Searchable путем объединения всех статей и всех продуктов в одну коллекцию внутри метода.
	5.	Напишем новый метод search в классе SearchService. Он должен принимать строку для поиска и возвращать коллекцию
		объектов SearchResult. Для написания метода воспользуйтесь Stream API. Сортировать результаты и дополнительно
		обрабатывать пока не надо.
	6.	Добавьте новый метод в контроллер. Это должен быть @GET-метод с путем /search. Он должен принимать аргумент pattern,
		который будет той самой строкой поиска. Метод должен возвращать коллекцию объектов SearchResult.

	Если все выполнено правильно и по шагам, при запросе localhost:8080/search?pattern=<какая-то строка> вы получите
	результаты поиска или пустой список.

Критерии оценки
Работа будет оценена по следующим критериям
	1. Пакеты model, model.search, model.product, model.article созданы, классы размещены согласно условиям.
	2. Поле id есть во всех классах, объявлено как private final, инициализировано в конструкторе
	3. Метод getId() корректно реализован в Product, Article и интерфейсе Searchable
	4. Классы помечены @Service
	5. Обе мапы объявлены как private final, инициализированы в конструкторе
	6. Тестовые объекты созданы с уникальными UUID, добавлены в мапы через отдельный приватный метод
	7. Класс помечен @RestController, методы search(), getAllProducts() и getAllArticles() — @GetMapping
	8. Поля searchTerm и contentType отсутствуют в JSON-ответе
	9. Поля id, name, contentType — final, сеттеры отсутствуют
	10. Метод fromSearchable() есть, корректно преобразует Searchable в SearchResult (соответствующие поля в соответствующие поля, то есть name в name)
	11. Поле StorageService помечено как private final, инициализировано через конструктор
	12. Поля SearchService и StorageService помечены как private final, инициализировано через конструктор
	13. Поиск реализован через цепочку stream().filter(...).map(...).collect(...)
	14. Эндпоинт возвращает отфильтрованные результаты в виде коллекции SearchResult
 */